{
  "hash": "24ca846a20937e858e5b2f9feb8d5e74",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Take-Home Exercise 03 - Predictive Model on HDB Resale Prices\"\nauthor: \"Lau Jia Yi\"\ndate: October 28, 2024\ndate-modified: \"last-modified\"\nexecute:\n  eval: true\n  echo: true\n  warning: false\n  freeze: true\n---\n\n\n\n# 1 Introduction\n\nThe aim of this exercise is to calibrate a predictive model to predict the HDB resale prices between July - September 2024 by using HDB resale transaction records in 2023.\n\nWe will be using a list of predictors as follows:\n\nStructural Factors:\n\n-   Area of the unit\n-   Floor level\n-   Remaining lease\n-   Age of the unit\n-   Main Upgrading Program (MUP) Completed\n\nLocational factors\n\n-   Proximity to:\n    -   CBD\n    -   Eldercare centres\n    -   Foodcourt/hawker centres\n    -   MRT Stations\n    -   Park\n    -   Good Primary School (Gifted Education Programme)\n    -   Shopping mall\n    -   Supermarket\n-   Number of:\n    -   Kindergartens within 350m\n\n    -   Childcare centres within 350m\n\n    -   Bus stop within 350m\n\n    -   Primary school within 1km\n\nAs I have selected the above predictors, I will be selecting five-room HDBs as the focus of this study as it will be able to accomodate multi-generation families in the most suitable/comfortable manner. This study would not consider other larger flat types such as executive and multi-generation which were included in the dataset as well.\n\n## 1.1 Preparing the Data\n\nLoading the required R packages as below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(tmap, \n               SpatialAcc, \n               sf, \n               reshape2,\n               tidyverse,\n               dplyr,\n               ggplot2,\n               httr,\n               jsonlite,\n               spdep,\n               GWmodel,\n               SpatialML,\n               tmap,\n               rsample,\n               Metrics)\n```\n:::\n\n\n\n### 1.1.1 HDB Resale Data\n\nHDB Data on resale prices is is obtained from Data.gov.sg. The resale prices are provided in a CSV format. Hence we will import it via read_csv.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhdb_r <- read_csv(\"data/hdb/resale.csv\")\n```\n:::\n\n\n\nFiltering the dataset for the relevant time period (Year 2023) and flat types will be done with the following code chunk.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Convert 'month' to Date type\nhdb_r <- hdb_r %>%\n  mutate(month = as.Date(paste0(month, \"-01\")))  # Ensure the 'month' column is a Date type\n\n# Filter for data from 2023\nhdb_r_2023 <- hdb_r %>%\n  filter(year(month) == 2023)\n\n# Filter for 5 ROOM HDB Flats only\n\nhdb5rm_r_2023 <- hdb_r_2023 %>%\n  filter(flat_type == \"5 ROOM\")\n```\n:::\n\n\n\nA quick check on the data table prepared to only contain the data required - 5 Room HDBs and 2023 transaction data is performed with the code chunks below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(hdb5rm_r_2023)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 11\n  month      town       flat_type block street_name  storey_range floor_area_sqm\n  <date>     <chr>      <chr>     <chr> <chr>        <chr>                 <dbl>\n1 2023-01-01 ANG MO KIO 5 ROOM    306   ANG MO KIO … 16 TO 18                123\n2 2023-01-01 ANG MO KIO 5 ROOM    306   ANG MO KIO … 04 TO 06                123\n3 2023-01-01 ANG MO KIO 5 ROOM    402   ANG MO KIO … 10 TO 12                119\n4 2023-01-01 ANG MO KIO 5 ROOM    259   ANG MO KIO … 13 TO 15                135\n5 2023-01-01 ANG MO KIO 5 ROOM    176   ANG MO KIO … 04 TO 06                119\n6 2023-01-01 ANG MO KIO 5 ROOM    618   ANG MO KIO … 13 TO 15                133\n# ℹ 4 more variables: flat_model <chr>, lease_commence_date <dbl>,\n#   remaining_lease <chr>, resale_price <dbl>\n```\n\n\n:::\n\n```{.r .cell-code}\ntable(hdb5rm_r_2023$flat_type)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n5 ROOM \n  5843 \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Group data by month and count the number of units sold\nunits_sold_per_month <- hdb5rm_r_2023 %>%\n  group_by(month) %>%\n  summarise(units_sold = n())\n\n# Plot the number of units sold using a bar chart with data labels\nggplot(units_sold_per_month, aes(x = month, y = units_sold)) +\n  geom_col(fill = \"steelblue\") +\n  geom_text(aes(label = units_sold), vjust = -0.5, color = \"black\", size = 3) +\n  scale_x_date(date_breaks = \"3 months\", date_labels = \"%b\") +\n  labs(title = \"Number of 5-Room HDB Units Sold in 2023\",\n       x = \"Month\",\n       y = \"Units Sold\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex03b_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n\nWe further extract the numerical value of the \"storey_range\" variable from the dataset to calculate the midpoint for further quantitative analysis in our subsequent worksteps.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract the numerical midpoint of 'storey_range'\nhdb5rm_r_2023 <- hdb5rm_r_2023 %>%\n  mutate(\n    storey_mid = storey_range %>%\n      gsub(\" TO \", \"-\", .) %>%\n      purrr::map_dbl(~ mean(as.numeric(unlist(strsplit(.x, \"-\"))))),\n    floor_area_sqm = as.numeric(floor_area_sqm)  # Ensure floor_area_sqm is numeric\n  )\n```\n:::\n\n\n\nTo calculate the age of the unit and remaining lease in years we use the following code chunk:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Assuming 'construction_year' is available or known\ncurrent_year <- 2024  # Use 2024 as the base year for calculation\nhdb5rm_r_2023 <- hdb5rm_r_2023 %>%\n  mutate(\n    age_of_unit = current_year - as.numeric(lease_commence_date),\n    remaining_lease = 99 - age_of_unit  # Assuming a 99-year lease\n  )\n```\n:::\n\n\n\nWe use the following code chunk to fetch the longitude and latitude of the HDB resale data via the address within from the OneMap API.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define the function to get coordinates from OneMap API\nget_coords <- function(add_list) {\n  # Create a data frame to store all retrieved coordinates\n  postal_coords <- data.frame()\n  \n  for (i in add_list) {\n    tryCatch({\n      r <- GET('https://www.onemap.gov.sg/api/common/elastic/search?',\n               query = list(searchVal = i,\n                            returnGeom = 'Y',\n                            getAddrDetails = 'Y'))\n      data <- fromJSON(rawToChar(r$content))\n      found <- data$found\n      res <- data$results\n      \n      # Create a new data frame for each address\n      new_row <- data.frame()\n      \n      if (found == 1) {\n        postal <- res$POSTAL\n        lat <- res$LATITUDE\n        lng <- res$LONGITUDE\n        new_row <- data.frame(address = i, \n                              postal = postal, \n                              latitude = lat, \n                              longitude = lng)\n      } else if (found > 1) {\n        res_sub <- res[res$POSTAL != \"NIL\", ]\n        \n        if (nrow(res_sub) == 0) {\n          new_row <- data.frame(address = i, \n                                postal = NA, \n                                latitude = NA, \n                                longitude = NA)\n        } else {\n          top1 <- head(res_sub, n = 1)\n          postal <- top1$POSTAL\n          lat <- top1$LATITUDE\n          lng <- top1$LONGITUDE\n          new_row <- data.frame(address = i, \n                                postal = postal, \n                                latitude = lat, \n                                longitude = lng)\n        }\n      } else {\n        new_row <- data.frame(address = i, \n                              postal = NA, \n                              latitude = NA, \n                              longitude = NA)\n      }\n      \n      postal_coords <- rbind(postal_coords, new_row)\n      Sys.sleep(0.1)  # Rate limiting\n      \n    }, error = function(e) {\n      message(paste(\"Error retrieving data for address:\", i))\n      new_row <- data.frame(address = i, \n                            postal = NA, \n                            latitude = NA, \n                            longitude = NA)\n      postal_coords <- rbind(postal_coords, new_row)\n    })\n  }\n  return(postal_coords)\n}\n\n# Create a unique address list for geocoding\naddress_list <- unique(hdb5rm_r_2023 %>% \n  mutate(address = paste(block, street_name, town, \"Singapore\")) %>% \n  pull(address))\n\n# Get coordinates for each unique address\ncoords_df <- get_coords(address_list)\n\n# Ensure coords_df has unique addresses before joining\ncoords_df <- coords_df %>% \n  distinct(address, .keep_all = TRUE)\n\n# Merge the coordinates back with the original data frame\nhdb5rm_r_2023 <- hdb5rm_r_2023 %>%\n  mutate(address = paste(block, street_name, town, \"Singapore\")) %>%\n  left_join(coords_df, by = \"address\")\n\n# Check the final number of observations\nnrow(hdb5rm_r_2023)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(hdb5rm_r_2023)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 13\n  month      town       flat_type block street_name  storey_range floor_area_sqm\n  <date>     <chr>      <chr>     <chr> <chr>        <chr>                 <dbl>\n1 2023-01-01 ANG MO KIO 5 ROOM    306   ANG MO KIO … 16 TO 18                123\n2 2023-01-01 ANG MO KIO 5 ROOM    306   ANG MO KIO … 04 TO 06                123\n3 2023-01-01 ANG MO KIO 5 ROOM    402   ANG MO KIO … 10 TO 12                119\n4 2023-01-01 ANG MO KIO 5 ROOM    259   ANG MO KIO … 13 TO 15                135\n5 2023-01-01 ANG MO KIO 5 ROOM    176   ANG MO KIO … 04 TO 06                119\n6 2023-01-01 ANG MO KIO 5 ROOM    618   ANG MO KIO … 13 TO 15                133\n# ℹ 6 more variables: flat_model <chr>, lease_commence_date <dbl>,\n#   remaining_lease <dbl>, resale_price <dbl>, storey_mid <dbl>,\n#   age_of_unit <dbl>\n```\n\n\n:::\n:::\n\n\n\nSave it into rds format to reduce subsequent loading time as the OneMap API takes time to extract the location for each transaction data.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(hdb5rm_r_2023, \"data/rds/hdb5rm_r_2023_loc.rds\")\n```\n:::\n\n\n\nRead from the saved RDS.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhdb5rm_r_2023_loc <- read_rds(\"data/rds/hdb5rm_r_2023_loc.rds\")\n```\n:::\n\n\n\nEnsuring CRS is 3414\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhdb5rm_r_2023_sf <- st_as_sf(hdb5rm_r_2023_loc, coords = c(\"longitude\", \"latitude\"),crs=4326)\nst_transform(hdb5rm_r_2023_sf, crs = 3414)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 5843 features and 15 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 11755.72 ymin: 28211.46 xmax: 46810.43 ymax: 48741.06\nProjected CRS: SVY21 / Singapore TM\n# A tibble: 5,843 × 16\n   month      town       flat_type block street_name storey_range floor_area_sqm\n * <date>     <chr>      <chr>     <chr> <chr>       <chr>                 <dbl>\n 1 2023-01-01 ANG MO KIO 5 ROOM    306   ANG MO KIO… 16 TO 18                123\n 2 2023-01-01 ANG MO KIO 5 ROOM    306   ANG MO KIO… 04 TO 06                123\n 3 2023-01-01 ANG MO KIO 5 ROOM    402   ANG MO KIO… 10 TO 12                119\n 4 2023-01-01 ANG MO KIO 5 ROOM    259   ANG MO KIO… 13 TO 15                135\n 5 2023-01-01 ANG MO KIO 5 ROOM    176   ANG MO KIO… 04 TO 06                119\n 6 2023-01-01 ANG MO KIO 5 ROOM    618   ANG MO KIO… 13 TO 15                133\n 7 2023-01-01 ANG MO KIO 5 ROOM    520   ANG MO KIO… 19 TO 21                118\n 8 2023-01-01 ANG MO KIO 5 ROOM    700C  ANG MO KIO… 19 TO 21                111\n 9 2023-01-01 ANG MO KIO 5 ROOM    714   ANG MO KIO… 10 TO 12                119\n10 2023-01-01 ANG MO KIO 5 ROOM    253   ANG MO KIO… 04 TO 06                128\n# ℹ 5,833 more rows\n# ℹ 9 more variables: flat_model <chr>, lease_commence_date <dbl>,\n#   remaining_lease <dbl>, resale_price <dbl>, storey_mid <dbl>,\n#   age_of_unit <dbl>, address <chr>, postal <chr>, geometry <POINT [m]>\n```\n\n\n:::\n\n```{.r .cell-code}\nst_crs(hdb5rm_r_2023_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCoordinate Reference System:\n  User input: EPSG:4326 \n  wkt:\nGEOGCRS[\"WGS 84\",\n    ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n        MEMBER[\"World Geodetic System 1984 (Transit)\"],\n        MEMBER[\"World Geodetic System 1984 (G730)\"],\n        MEMBER[\"World Geodetic System 1984 (G873)\"],\n        MEMBER[\"World Geodetic System 1984 (G1150)\"],\n        MEMBER[\"World Geodetic System 1984 (G1674)\"],\n        MEMBER[\"World Geodetic System 1984 (G1762)\"],\n        MEMBER[\"World Geodetic System 1984 (G2139)\"],\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]],\n        ENSEMBLEACCURACY[2.0]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"geodetic latitude (Lat)\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"geodetic longitude (Lon)\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    USAGE[\n        SCOPE[\"Horizontal component of 3D system.\"],\n        AREA[\"World.\"],\n        BBOX[-90,-180,90,180]],\n    ID[\"EPSG\",4326]]\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhdb5rm_r_2023_sf2 <- st_transform(hdb5rm_r_2023_sf, crs = 3414)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(hdb5rm_r_2023_sf2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]\n```\n\n\n:::\n:::\n\n\n\n### 1.1.2 Preparing the other locational factors (Proximity)\n\n#### 1.1.2.1 Proximity to CBD\n\nWe will calculate the distance from each HDB to the CBD, point coordinate approximated as 1.283423, 103.851959.\n\nThe results are then added back as \"**dist_to_cbd**\" in the hdb sf data frame.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Add the coordinates for the CBD\ncbd_coords <- data.frame(\n  name = \"CBD\",\n  longitude = 103.851959,  # Approximate longitude of Singapore's CBD\n  latitude = 1.283423      # Approximate latitude of Singapore's CBD\n)\n\n# Convert CBD to an sf object\ncbd_sf <- st_as_sf(cbd_coords, coords = c(\"longitude\", \"latitude\"), crs = 4326)\ncbd_sf2 <- st_transform(cbd_sf, crs = 3414)\n\n# Calculate distance from HDB locations to the CBD\nhdb5rm_r_2023_sf2 <- hdb5rm_r_2023_sf2 %>%\n  mutate(\n    dist_to_cbd = st_distance(geometry, cbd_sf2) %>% as.numeric() / 1000  # Convert to kilometers\n  )\n```\n:::\n\n\n\n#### 1.1.2.2 Proximity to Eldercare services\n\nLoad the location dataset of eldercare services downloaded from data.gov.sg. Ensure it is in CRS 3414 to calculate proximity / distance in metres / KM.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Read the eldercare GeoJSON file\neldercare_sf <- st_read(\"data/eldercare/EldercareServices.geojson\", crs = 4326)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `EldercareServices' from data source \n  `C:\\Users\\jia_y\\OneDrive - Singapore Management University\\Semester 4\\ISSS626-G1 Geo Spatial Analytics and Applications\\jylau91\\ISSS626-GAA\\Take-home_Ex\\Take-home_Ex03\\data\\eldercare\\EldercareServices.geojson' \n  using driver `GeoJSON'\nSimple feature collection with 133 features and 2 fields\nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 103.7119 ymin: 1.271472 xmax: 103.9561 ymax: 1.439561\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n\n```{.r .cell-code}\neldercare_sf2 <- st_transform(eldercare_sf, crs = 3414)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(eldercare_sf2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]\n```\n\n\n:::\n:::\n\n\n\nCalculating the minimum distance using st_distance against the list of eldercare services followed by a minimum function.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate distances from each HDB point to the nearest eldercare center\nhdb5rm_r_2023_sf2 <- hdb5rm_r_2023_sf2 %>%\n  mutate(dist_to_eldercare = st_distance(geometry, eldercare_sf2) %>% apply(1, min))\n\n# Convert distances from meters to kilometers\nhdb5rm_r_2023_sf2 <- hdb5rm_r_2023_sf2 %>%\n  mutate(dist_to_eldercare = as.numeric(dist_to_eldercare) / 1000)\n```\n:::\n\n\n\nPlot the coordinates to ensure that the HDB and services are plotted on the same coordinate system.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tmap)\ntmap_mode(\"plot\")\ntm_shape(hdb5rm_r_2023_sf2) + tm_dots(col = \"blue\") +\n  tm_shape(eldercare_sf2) + tm_dots(col = \"red\")\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex03b_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\n\n#### 1.1.2.3 Proximity to a Hawker centre\n\nWe now repeat the steps from 1.1.2.2 to 1.1.2.8 for the respective services.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Read the hawker centres GeoJSON file\nhawker_centres_sf <- st_read(\"data/hawker_food/HawkerCentresGEOJSON.geojson\", crs = 4326)\nhawker_centres_sf2 <- st_transform(hawker_centres_sf, crs = 3414)\n\n# Check the CRS to confirm it's transformed correctly\nst_crs(hawker_centres_sf2)\n\n# Calculate distances from each HDB point to the nearest hawker centre\nhdb5rm_r_2023_sf2 <- hdb5rm_r_2023_sf2 %>%\n  mutate(dist_to_hawker = st_distance(geometry, hawker_centres_sf2) %>% apply(1, min))\n\n# Convert distances from meters to kilometers\nhdb5rm_r_2023_sf2 <- hdb5rm_r_2023_sf2 %>%\n  mutate(dist_to_hawker = as.numeric(dist_to_hawker) / 1000)\n\n# Visualize the HDB locations and hawker centres for verification\nlibrary(tmap)\ntmap_mode(\"plot\")\ntm_shape(hdb5rm_r_2023_sf2) + tm_dots(col = \"blue\") +\n  tm_shape(hawker_centres_sf2) + tm_dots(col = \"green\")\n```\n:::\n\n\n\n#### 1.1.2.4 Proximity to a MRT Station\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Read the MRT stations GeoJSON file\nmrt_stations_sf <- st_read(\"data/mrt/LTAMRTStationExitGEOJSON.geojson\", crs = 4326)\nmrt_stations_sf2 <- st_transform(mrt_stations_sf, crs = 3414)\n\n# Check the CRS to confirm it's transformed correctly\nst_crs(mrt_stations_sf2)\n\n# Calculate distances from each HDB point to the nearest MRT station\nhdb5rm_r_2023_sf2 <- hdb5rm_r_2023_sf2 %>%\n  mutate(dist_to_mrt = st_distance(geometry, mrt_stations_sf2) %>% apply(1, min))\n\n# Convert distances from meters to kilometers\nhdb5rm_r_2023_sf2 <- hdb5rm_r_2023_sf2 %>%\n  mutate(dist_to_mrt = as.numeric(dist_to_mrt) / 1000)\n\n# Visualize the HDB locations and MRT stations for verification\nlibrary(tmap)\ntmap_mode(\"plot\")\ntm_shape(hdb5rm_r_2023_sf2) + tm_dots(col = \"blue\") +\n  tm_shape(mrt_stations_sf2) + tm_dots(col = \"orange\")\n```\n:::\n\n\n\n#### 1.1.2.5 Proximity to a Park\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Read the parks GeoJSON file\nparks_sf <- st_read(\"data/park/ParkFacilitiesGEOJSON.geojson\", crs = 4326)\nparks_sf2 <- st_transform(parks_sf, crs = 3414)\n\n# Check the CRS to confirm it's transformed correctly\nst_crs(parks_sf2)\n\n# Calculate distances from each HDB point to the nearest park\nhdb5rm_r_2023_sf2 <- hdb5rm_r_2023_sf2 %>%\n  mutate(dist_to_park = st_distance(geometry, parks_sf2) %>% apply(1, min))\n\n# Convert distances from meters to kilometers\nhdb5rm_r_2023_sf2 <- hdb5rm_r_2023_sf2 %>%\n  mutate(dist_to_park = as.numeric(dist_to_park) / 1000)\n\n# Visualize the HDB locations and parks for verification\nlibrary(tmap)\ntmap_mode(\"plot\")\ntm_shape(hdb5rm_r_2023_sf2) + tm_dots(col = \"blue\") +\n  tm_shape(parks_sf2) + tm_dots(col = \"green\")\n```\n:::\n\n\n\n#### 1.1.2.6 Proximity to a Supermarket\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Read the supermarkets GeoJSON file\nsupermarkets_sf <- st_read(\"data/supermarket/SupermarketsGEOJSON.geojson\", crs = 4326)\nsupermarkets_sf2 <- st_transform(supermarkets_sf, crs = 3414)\n\n# Check the CRS to confirm it's transformed correctly\nst_crs(supermarkets_sf2)\n\n# Calculate distances from each HDB point to the nearest supermarket\nhdb5rm_r_2023_sf2 <- hdb5rm_r_2023_sf2 %>%\n  mutate(dist_to_supermarket = st_distance(geometry, supermarkets_sf2) %>% apply(1, min))\n\n# Convert distances from meters to kilometers\nhdb5rm_r_2023_sf2 <- hdb5rm_r_2023_sf2 %>%\n  mutate(dist_to_supermarket = as.numeric(dist_to_supermarket) / 1000)\n\n# Visualize the HDB locations and supermarkets for verification\nlibrary(tmap)\ntmap_mode(\"plot\")\ntm_shape(hdb5rm_r_2023_sf2) + tm_dots(col = \"blue\") +\n  tm_shape(supermarkets_sf2) + tm_dots(col = \"orange\")\n```\n:::\n\n\n\n#### 1.1.2.7 Proximity to a Shopping Mall\n\nTo obtain the list of Shopping Malls we will scrape OpenStreetMap\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get Singapore's bounding box\nsingapore_bbox <- getbb(\"Singapore\")\n\n# Define the tag for shopping malls\ntag <- \"mall\"\n\n# Retrieve data from OpenStreetMap using the bounding box for Singapore\nmall_data <- opq(bbox = singapore_bbox) %>%\n  add_osm_feature(key = \"shop\", value = tag) %>%\n  osmdata_sf()\n\n# Extract point and polygon geometries (malls), calculate centroids for polygons\nmall_points <- mall_data$osm_points %>% select(osm_id, name, geometry)\nmall_polygons <- mall_data$osm_polygons %>% \n  select(osm_id, name, geometry) %>%\n  mutate(geometry = st_centroid(geometry)) # Convert polygons to centroids\n\n# Combine points and polygons into one dataset\nshop_mall <- bind_rows(mall_points, mall_polygons) %>%\n  filter(!is.na(name)) # Filter to keep only malls with names\n\n# Load a detailed boundary of Singapore to use as a spatial filter\nsingapore_boundary <- opq(bbox = singapore_bbox) %>%\n  add_osm_feature(key = \"admin_level\", value = \"2\") %>%\n  osmdata_sf() %>%\n  .$osm_multipolygons %>%\n  filter(name == \"Singapore\")\n\n# Spatial filter: keep only malls within Singapore's boundary\nshop_mall <- shop_mall %>%\n  st_transform(st_crs(singapore_boundary)) %>%\n  st_intersection(singapore_boundary)\n\n# Extract latitude and longitude from geometry\nshop_mall <- shop_mall %>%\n  mutate(latitude = st_coordinates(geometry)[,2],\n         longitude = st_coordinates(geometry)[,1])\n\n# Keep only the specified columns\nshop_mall <- shop_mall %>% select(name, osm_id, longitude, latitude, geometry)\n\n# Display the data for confirmation\nhead(shop_mall)\n\n# Save to a CSV file\nwrite.csv(shop_mall %>% select(name, osm_id, longitude, latitude), \n          \"data/shop_mall/shop_mall_centroids.csv\", row.names = FALSE)\n```\n:::\n\n\n\nTransform the scrapped data into CRS 3414.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshop_mall <- st_transform(shop_mall, crs = 3414)\n```\n:::\n\n\n\nPerform the same st_distance calculation against our HDB dataset.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Ensure that shop_mall is in the correct CRS (3414)\nshop_mall_sf <- st_transform(shop_mall, crs = 3414)\n\n# Check the CRS to confirm it's transformed correctly\nst_crs(shop_mall_sf)\n\n# Calculate distances from each HDB point to the nearest shopping mall\nhdb5rm_r_2023_sf2 <- hdb5rm_r_2023_sf2 %>%\n  mutate(dist_to_mall = st_distance(geometry, shop_mall_sf) %>% apply(1, min))\n\n# Convert distances from meters to kilometers\nhdb5rm_r_2023_sf2 <- hdb5rm_r_2023_sf2 %>%\n  mutate(dist_to_mall = as.numeric(dist_to_mall) / 1000)\n\n# Visualize the HDB locations and shopping malls for verification\nlibrary(tmap)\ntmap_mode(\"plot\")\ntm_shape(hdb5rm_r_2023_sf2) + tm_dots(col = \"blue\") +\n  tm_shape(shop_mall_sf) + tm_dots(col = \"orange\")\n```\n:::\n\n\n\n#### 1.1.2.8 Proximity to a Good Primary School\n\nNext, we will take primary schools that offers the Gifted Education Program as a proxy or identifier of a good primary school. There are other subjective methods such as calculating the number of applications over student cohort that could be considered.\n\n::: {callout-tip}\n## Myth or not: Every School is a Good School?\n\nAlthough every school is a good school as a former Minister of Education had previously stated, but our current PM Lawrence Wong added on \"but not everyone is convinced.\" We have also learnt other wise from Data Analytics Labs. Afterall a good school or right school might be more than academic results as jobs evolves from specific domain knowledge.\n:::\n\nListed on MOE's website are these 9 primary schools, I have extracted the address from the website manually and saved them into a CSV file.\n\n|                                        |                                      |\n|-------------------------------------|-----------------------------------|\n| School                                 | Address                              |\n| Anglo-Chinese School (Primary)         | 50 Barker Road, S309918              |\n| Catholic High School (Primary Section) | 9 Bishan Street 22, S579767          |\n| Henry Park Primary School              | 1 Holland Grove Road, S278790        |\n| Nan Hua Primary School                 | 30 Jalan Lempeng, S128806            |\n| Nanyang Primary School                 | 52 King's Road, S268097              |\n| Raffles Girls' Primary School          | 21 Hillcrest Road, S289072           |\n| Rosyth School                          | 21 Serangoon North Avenue 4, S555855 |\n| St. Hilda's Primary School             | 2 Tampines Ave 3, S529706            |\n| Tao Nan School                         | 49 Marine Crescent, S449761          |\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngpsch <- read_csv(\"data/gpschool/g_pri_sch.csv\")\n```\n:::\n\n\n\nWe will re-use the earlier function \"get_coords\" in section 1.1.1.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a unique address list for geocoding\ngpsch_address_list <- unique(gpsch %>% \n  pull(address))\n\n# Get coordinates for each unique address\ncoords_df <- get_coords(gpsch_address_list)\n\n# Ensure coords_df has unique addresses before joining\ncoords_df <- coords_df %>% \n  distinct(address, .keep_all = TRUE)\n\n# Merge the coordinates back with the original data frame\ngpsch <- gpsch %>%\n  left_join(coords_df, by = \"address\")\n\ngpsch_sf <- st_as_sf(gpsch, coords = c(\"longitude\", \"latitude\"),crs=4326)\ngpsch_sf2 <- st_transform(gpsch_sf, crs = 3414)\nst_crs(gpsch_sf2)\n```\n:::\n\n\n\nFollowed by a calculation using st_distance again.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate distances from each HDB point to the nearest good primary school\nhdb5rm_r_2023_sf2 <- hdb5rm_r_2023_sf2 %>%\n  mutate(dist_to_gpsch = st_distance(geometry, gpsch_sf2) %>% apply(1, min))\n\n# Convert distances from meters to kilometers\nhdb5rm_r_2023_sf2 <- hdb5rm_r_2023_sf2 %>%\n  mutate(dist_to_gpsch = as.numeric(dist_to_gpsch) / 1000)\n\n# Visualize the HDB locations and shopping malls for verification\nlibrary(tmap)\ntmap_mode(\"plot\")\ntm_shape(hdb5rm_r_2023_sf2) + tm_dots(col = \"blue\") +\n  tm_shape(gpsch_sf2) + tm_dots(col = \"red\")\n```\n:::\n\n\n\n### 1.1.3 Preparing the other locational factors (Number of services)\n\n#### 1.1.3.1 Number of Kindergartens within 350m\n\nFirst we load the kindergartens location data from data.gov.sg, and transform it into CRS 3414.\n\nWe then use the following codes to count the number of kindergartens within 350m.\n\n-   st_buffer: 350m buffer around each HDB location.\n-   st_within: checking if the point data in kindergartens_sf fall within the st_buffer created.\n-   sapply: iterates over each row data in hdb5m_r_2023_sf2 data table to count how many kindergartens fall within the buffer.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load the kindergarten data\nkindergartens_sf <- st_read(\"data/kindergartens/kindergartens.geojson\")\n\n# Ensure the kindergarten data is in the correct CRS (EPSG 3414)\nkindergartens_sf <- st_transform(kindergartens_sf, crs = 3414)\n\n# Create a buffer of 350m around each HDB location\nhdb5rm_r_2023_sf2 <- hdb5rm_r_2023_sf2 %>%\n  mutate(kindergarten_count = sapply(st_geometry(.), function(hdb_point) {\n    sum(st_within(kindergartens_sf, st_buffer(hdb_point, 350), sparse = FALSE))\n  }))\n\n# View the updated HDB data with kindergarten count\nhead(hdb5rm_r_2023_sf2)\n```\n:::\n\n\n\nWe will then repeat this for sections 1.1.3.2 to 1.1.3.4 for the count of other services.\n\n#### 1.1.3.2 Number of Childcare centres within 350m\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load the childcare centers data\nchildcare_sf <- st_read(\"data/childcare/ChildCareServices.geojson\")\n\n# Ensure the childcare data is in the correct CRS (EPSG 3414)\nchildcare_sf <- st_transform(childcare_sf, crs = 3414)\n\n# Create a buffer of 350m around each HDB location and count childcare centers within that buffer\nhdb5rm_r_2023_sf2 <- hdb5rm_r_2023_sf2 %>%\n  mutate(childcare_count = sapply(st_geometry(.), function(hdb_point) {\n    sum(st_within(childcare_sf, st_buffer(hdb_point, 350), sparse = FALSE))\n  }))\n\n# View the updated HDB data with childcare count\nhead(hdb5rm_r_2023_sf2)\n```\n:::\n\n\n\n#### 1.1.3.3 Number of Bus Stop within 350m\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load the bus stop data and transform to CRS 3414\nbus_stop <- st_read(dsn = \"data/bus_stop\", layer = \"BusStop\") %>%\n  st_transform(crs = 3414)\n\n# Create a buffer of 350m around each HDB location and count bus stops within that buffer\nhdb5rm_r_2023_sf2 <- hdb5rm_r_2023_sf2 %>%\n  mutate(bus_stop_count = sapply(st_geometry(.), function(hdb_point) {\n    sum(st_within(bus_stop, st_buffer(hdb_point, 350), sparse = FALSE))\n  }))\n\n# View the updated HDB data with bus stop count\nhead(hdb5rm_r_2023_sf2)\n```\n:::\n\n\n\n#### 1.1.3.4 Number of Primary school within 1km\n\nFirst, we obtain the General Information of Schools from data.gov.sg \"School Directory and Information\" and load the CSV.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npsch <- read_csv(\"data/pschool/GIOS.csv\")\n\npsch <- psch %>%\n  select(school_name, address, mainlevel_code) %>%\n  filter(mainlevel_code == \"PRIMARY\")\n\n# Create a unique address list for geocoding\npsch_address_list <- unique(psch %>% pull(address))\n\n# Get coordinates for each unique address using the provided get_coords function\ncoords_df <- get_coords(psch_address_list)\n\n# Ensure coords_df has unique addresses before joining\ncoords_df <- coords_df %>%\n  distinct(address, .keep_all = TRUE)\n\n# Merge the coordinates back with the original data frame\npsch <- psch %>%\n  left_join(coords_df, by = \"address\")\n\n# Convert to sf object and transform to CRS 3414\npsch_sf <- st_as_sf(psch, coords = c(\"longitude\", \"latitude\"), crs = 4326)\npsch_sf2 <- st_transform(psch_sf, crs = 3414)\n\n# Display CRS to confirm the transformation\nst_crs(psch_sf2)\n```\n:::\n\n\n\nWe then count the number of primary schools using psch_sf2 and the HDB buffer point as per the steps performed from 1.1.3.1 again.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a buffer of 350m around each HDB location and count bus stops within that buffer\nhdb5rm_r_2023_sf2 <- hdb5rm_r_2023_sf2 %>%\n  mutate(psch_count = sapply(st_geometry(.), function(hdb_point) {\n    sum(st_within(psch_sf2, st_buffer(hdb_point, 350), sparse = FALSE))\n  }))\n\n# View the updated HDB data with bus stop count\nhead(hdb5rm_r_2023_sf2)\n```\n:::\n\n\n\nAfter all the calculations for section 1.1.2 and 1.1.3 is done, we will write the HDB sf file into rds to save subsequent rendering and loading times.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(hdb5rm_r_2023_sf2, \"data/rds/hdb5rm_r_2023_sf2.rds\")\n```\n:::\n\n\n\nRead from the saved RDS.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhdb5rm_r_2023_sf2 <- read_rds(\"data/rds/hdb5rm_r_2023_sf2.rds\")\n```\n:::\n\n\n\n# 2 Building the predictive model\n\n## 2.1 Data Sampling\n\nThe entire data set is split into training and test datasets using 65% and 35% respectively using initial_split() the rsample package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(8888)\nresale_split <- initial_split(hdb5rm_r_2023_sf2,\n                              prop = 6.5/10,)\ntrain_data <- training(resale_split)\ntest_data <- testing(resale_split)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(train_data, \"data/model/train_data.rds\")\nwrite_rds(test_data, \"data/model/test_data.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntrain_data <- read_rds(\"data/model/train_data.rds\")\ntest_data <- read_rds(\"data/model/test_data.rds\")\n```\n:::\n\n\n\n## 2.2 Computing Correlation Matrix\n\nBefore loading the predictors into the predictive model, we will examine the dataset for any sign of multi-collinerarity.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhdb5rm_r_2023_sf2_nogeo <- hdb5rm_r_2023_sf2 %>%\n  st_drop_geometry() %>%\n  select_if(is.numeric)\n\ncorrplot::corrplot(cor(hdb5rm_r_2023_sf2_nogeo), \n                   diag = FALSE, \n                   order = \"AOE\",\n                   tl.pos = \"td\", \n                   tl.cex = 0.8, \n                   method = \"number\", \n                   type = \"upper\")\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex03b_files/figure-html/unnamed-chunk-40-1.png){width=672}\n:::\n:::\n\n\n\n::: callout-note\nThe perfect correlation of 1.0/-1.0 is noted between lease_commence_date and age_of_unit / remaining_lease as the three variables are just the differences of each other. We will leave it in the dataset for flexibility in further analysis and interpretation.\n:::\n\n## 2.3 Non-spatial multiple linear regression\n\nWe will first perform a non-spatial multiple linear regression of the structural and location factors mentioned in Section 1.0.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprice_mlr <- lm(resale_price ~ \n                  floor_area_sqm + \n                  storey_mid + \n                  remaining_lease +\n                  age_of_unit +\n                  dist_to_cbd +\n                  dist_to_eldercare +\n                  dist_to_hawker +\n                  dist_to_mrt +\n                  dist_to_park +\n                  dist_to_gpsch +\n                  dist_to_mall +\n                  dist_to_supermarket,\n                data=train_data)\nsummary(price_mlr)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = resale_price ~ floor_area_sqm + storey_mid + remaining_lease + \n    age_of_unit + dist_to_cbd + dist_to_eldercare + dist_to_hawker + \n    dist_to_mrt + dist_to_park + dist_to_gpsch + dist_to_mall + \n    dist_to_supermarket, data = train_data)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-383363  -45955   -5060   38856  468212 \n\nCoefficients: (1 not defined because of singularities)\n                     Estimate Std. Error t value Pr(>|t|)    \n(Intercept)         -330488.0    34509.1  -9.577  < 2e-16 ***\nfloor_area_sqm         6878.6      228.2  30.139  < 2e-16 ***\nstorey_mid             6741.2      227.2  29.669  < 2e-16 ***\nremaining_lease        6720.2      139.6  48.151  < 2e-16 ***\nage_of_unit                NA         NA      NA       NA    \ndist_to_cbd          -28789.3      606.8 -47.443  < 2e-16 ***\ndist_to_eldercare      5522.8     2105.5   2.623  0.00875 ** \ndist_to_hawker       -20110.0     2366.6  -8.498  < 2e-16 ***\ndist_to_mrt           -4581.8     3429.6  -1.336  0.18164    \ndist_to_park         -25779.7     5164.0  -4.992 6.24e-07 ***\ndist_to_gpsch          7415.3      623.6  11.892  < 2e-16 ***\ndist_to_mall          10002.4     3458.4   2.892  0.00385 ** \ndist_to_supermarket   25734.0     8499.1   3.028  0.00248 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 77490 on 3785 degrees of freedom\nMultiple R-squared:  0.6911,\tAdjusted R-squared:  0.6902 \nF-statistic: 769.9 on 11 and 3785 DF,  p-value: < 2.2e-16\n```\n\n\n:::\n:::\n\n\n\n::: {.callout-tip title=\"Model Summary\"}\n-   **Multiple R-squared: 0.6911**: This means that about **69.11%** of the variance in resale prices is explained by the predictors in the model. This is a good fit, but there's still a fair amount of unexplained variance.\n\n-   **Adjusted R-squared: 0.6902**: This value adjusts for the number of predictors in the model and confirms that the model fit is still quite good after accounting for the number of predictors.\n\n-   **F-statistic: 769.9** with a **p-value \\< 2.2e-16**: This tests the overall significance of the regression model. Since the p-value is very small, the model is statistically significant and has a high explanatory power.\n\nStrong predictors of resale price include floor_area_sqm, storey_mid, remaining_lease, dist_to_cbd, dist_to_eldercare, dist_to_hawker, dist_to_park, dist_to_gpsch, dist_to_mall, and dist_to_supermarket.\n\nWeaker predictors such as proximity to MRT stations will be removed in subsequent models as it is statistically not significant.\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprice_mlr <- lm(resale_price ~ \n                  floor_area_sqm + \n                  storey_mid + \n                  remaining_lease +\n                  age_of_unit +\n                  dist_to_cbd +\n                  dist_to_eldercare +\n                  dist_to_hawker +\n                  dist_to_park +\n                  dist_to_gpsch +\n                  dist_to_mall +\n                  dist_to_supermarket,\n                data=train_data)\nsummary(price_mlr)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = resale_price ~ floor_area_sqm + storey_mid + remaining_lease + \n    age_of_unit + dist_to_cbd + dist_to_eldercare + dist_to_hawker + \n    dist_to_park + dist_to_gpsch + dist_to_mall + dist_to_supermarket, \n    data = train_data)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-382782  -46594   -5013   38707  468405 \n\nCoefficients: (1 not defined because of singularities)\n                     Estimate Std. Error t value Pr(>|t|)    \n(Intercept)         -326092.6    34355.5  -9.492  < 2e-16 ***\nfloor_area_sqm         6840.8      226.5  30.203  < 2e-16 ***\nstorey_mid             6733.6      227.2  29.642  < 2e-16 ***\nremaining_lease        6710.2      139.4  48.143  < 2e-16 ***\nage_of_unit                NA         NA      NA       NA    \ndist_to_cbd          -28795.6      606.9 -47.449  < 2e-16 ***\ndist_to_eldercare      4934.1     2059.0   2.396  0.01661 *  \ndist_to_hawker       -20052.2     2366.4  -8.474  < 2e-16 ***\ndist_to_park         -26228.0     5153.6  -5.089 3.77e-07 ***\ndist_to_gpsch          7451.5      623.0  11.960  < 2e-16 ***\ndist_to_mall           8609.8     3297.9   2.611  0.00907 ** \ndist_to_supermarket   24820.8     8472.5   2.930  0.00341 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 77500 on 3786 degrees of freedom\nMultiple R-squared:  0.691,\tAdjusted R-squared:  0.6902 \nF-statistic: 846.5 on 10 and 3786 DF,  p-value: < 2.2e-16\n```\n\n\n:::\n:::\n\n\n\n## 2.4 gwr predictive method\n\nWe will next calibrate a model to predict HDB resale price by using geographically weighted regression method of GWmodel package.\n\n### 2.4.1 Converting train sf data frame to SpatialPointDataFrame\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrain_data_sp <- as_Spatial(train_data)\ntrain_data_sp\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatialPointsDataFrame \nfeatures    : 3797 \nextent      : 11755.72, 46810.43, 28211.46, 48741.06  (xmin, xmax, ymin, ymax)\ncrs         : +proj=tmerc +lat_0=1.36666666666667 +lon_0=103.833333333333 +k=1 +x_0=28001.642 +y_0=38744.572 +ellps=WGS84 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs \nvariables   : 27\nnames       : month,       town, flat_type, block,  street_name, storey_range, floor_area_sqm, flat_model, lease_commence_date, remaining_lease, resale_price, storey_mid, age_of_unit,                                address, postal, ... \nmin values  : 19358, ANG MO KIO,    5 ROOM,     1, ADMIRALTY DR,     01 TO 03,             99,       3Gen,                1970,              45,       418000,          2,           4,         1 CHAI CHEE RD BEDOK Singapore, 081003, ... \nmax values  : 19692,     YISHUN,    5 ROOM,    9B,      ZION RD,     43 TO 45,            153,    Type S2,                2020,              95,      1460000,         44,          54, 9B BOON TIONG RD BUKIT MERAH Singapore, 824677, ... \n```\n\n\n:::\n:::\n\n\n\n### 2.4.2 Computing adaptive bandwith for train data\n\nDetermine the optimal bandwith to be used via bw.gwr() of GWmodel package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbw_adaptive <- bw.gwr(resale_price ~\n                        floor_area_sqm + \n                        storey_mid + \n                        remaining_lease +\n                        age_of_unit +\n                        dist_to_cbd +\n                        dist_to_eldercare +\n                        dist_to_hawker +\n                        dist_to_park +\n                        dist_to_gpsch +\n                        dist_to_mall +\n                        dist_to_supermarket,\n                        data=train_data_sp,\n                        approach=\"CV\",\n                        kernel=\"gaussian\",\n                        adaptive=TRUE,\n                        longlat=FALSE)\n```\n:::\n\n\n\nThe result shows that 3065 neighbour points will be the optimal bandwidth to be used if adaptive bandwidth is used for this data set.\n\nWe will write and read bw_adaptive to avoid the long calculation time for the adaptive bandwith.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(bw_adaptive, \"data/model/bw_adaptive.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbw_adaptive <- read_rds(\"data/model/bw_adaptive.rds\")\n```\n:::\n\n\n\n### 2.4.3 Constructing the adaptive bandwith gwr model for train data\n\nTo calibrate the gwr-based hedonic pricing model by using adaptive bandwith and the Gaussian kernel using the code chunk below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngwr_adaptive <- gwr.basic(formula = resale_price ~\n                            floor_area_sqm + \n                            storey_mid + \n                            remaining_lease +\n                            age_of_unit +\n                            dist_to_cbd +\n                            dist_to_eldercare +\n                            dist_to_hawker +\n                            dist_to_park +\n                            dist_to_gpsch +\n                            dist_to_mall +\n                            dist_to_supermarket,\n                          data=train_data_sp,\n                          bw=bw_adaptive, \n                          kernel = 'gaussian', \n                          adaptive=TRUE,\n                          longlat = FALSE)\n```\n:::\n\n\n\nWe will write and read gwr_adaptive to store and avoid loading time.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(gwr_adaptive, \"data/model/gwr_adaptive.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngwr_adaptive <- read_rds(\"data/model/gwr_adaptive.rds\")\ngwr_adaptive\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   ***********************************************************************\n   *                       Package   GWmodel                             *\n   ***********************************************************************\n   Program starts at: 2024-11-10 16:13:08.045996 \n   Call:\n   gwr.basic(formula = resale_price ~ floor_area_sqm + storey_mid + \n    remaining_lease + age_of_unit + dist_to_cbd + dist_to_eldercare + \n    dist_to_hawker + dist_to_park + dist_to_gpsch + dist_to_mall + \n    dist_to_supermarket, data = train_data_sp, bw = bw_adaptive, \n    kernel = \"gaussian\", adaptive = TRUE, longlat = FALSE)\n\n   Dependent (y) variable:  resale_price\n   Independent variables:  floor_area_sqm storey_mid remaining_lease age_of_unit dist_to_cbd dist_to_eldercare dist_to_hawker dist_to_park dist_to_gpsch dist_to_mall dist_to_supermarket\n   Number of data points: 3797\n   ***********************************************************************\n   *                    Results of Global Regression                     *\n   ***********************************************************************\n\n   Call:\n    lm(formula = formula, data = data)\n\n   Residuals:\n    Min      1Q  Median      3Q     Max \n-382782  -46594   -5013   38707  468405 \n\n   Coefficients: (1 not defined because of singularities)\n                        Estimate Std. Error t value Pr(>|t|)    \n   (Intercept)         -326092.6    34355.5  -9.492  < 2e-16 ***\n   floor_area_sqm         6840.8      226.5  30.203  < 2e-16 ***\n   storey_mid             6733.6      227.2  29.642  < 2e-16 ***\n   remaining_lease        6710.2      139.4  48.143  < 2e-16 ***\n   age_of_unit                NA         NA      NA       NA    \n   dist_to_cbd          -28795.6      606.9 -47.449  < 2e-16 ***\n   dist_to_eldercare      4934.1     2059.0   2.396  0.01661 *  \n   dist_to_hawker       -20052.2     2366.4  -8.474  < 2e-16 ***\n   dist_to_park         -26228.0     5153.6  -5.089 3.77e-07 ***\n   dist_to_gpsch          7451.5      623.0  11.960  < 2e-16 ***\n   dist_to_mall           8609.8     3297.9   2.611  0.00907 ** \n   dist_to_supermarket   24820.8     8472.5   2.930  0.00341 ** \n\n   ---Significance stars\n   Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 \n   Residual standard error: 77500 on 3786 degrees of freedom\n   Multiple R-squared: 0.691\n   Adjusted R-squared: 0.6902 \n   F-statistic: 846.5 on 10 and 3786 DF,  p-value: < 2.2e-16 \n   ***Extra Diagnostic information\n   Residual sum of squares: 2.273806e+13\n   Sigma(hat): 77405.32\n   AIC:  96283.64\n   AICc:  96283.74\n   BIC:  92674.93\n   ***********************************************************************\n   *          Results of Geographically Weighted Regression              *\n   ***********************************************************************\n\n   *********************Model calibration information*********************\n   Kernel function: gaussian \n   Adaptive bandwidth: 3065 (number of nearest neighbours)\n   Regression points: the same locations as observations are used.\n   Distance metric: Euclidean distance metric is used.\n\n   ****************Summary of GWR coefficient estimates:******************\n                              Min.     1st Qu.      Median     3rd Qu.\n   Intercept           -1.4359e+08 -4.6410e+05  1.2529e+05  6.8694e+05\n   floor_area_sqm       6.6513e+03  6.7646e+03  7.1131e+03  7.2357e+03\n   storey_mid           6.5239e+03  6.6875e+03  6.7525e+03  6.8149e+03\n   remaining_lease     -1.9063e+06 -3.8314e+03  2.1069e+03  7.9490e+03\n   age_of_unit         -1.8576e+06 -1.0630e+04 -4.5961e+03  1.7402e+03\n   dist_to_cbd         -2.9471e+04 -2.9127e+04 -2.9011e+04 -2.8828e+04\n   dist_to_eldercare   -4.7075e+02  1.1548e+03  3.2754e+03  4.3116e+03\n   dist_to_hawker      -2.4960e+04 -2.4066e+04 -2.1531e+04 -1.8975e+04\n   dist_to_park        -2.8047e+04 -2.7750e+04 -2.6978e+04 -2.6753e+04\n   dist_to_gpsch        6.9449e+03  7.6369e+03  8.0696e+03  8.3483e+03\n   dist_to_mall        -1.0322e+03  4.6156e+02  8.1778e+03  1.3234e+04\n   dist_to_supermarket  1.5986e+04  1.9394e+04  2.2390e+04  2.5543e+04\n                              Max.\n   Intercept           190590906.7\n   floor_area_sqm           7339.0\n   storey_mid               7123.5\n   remaining_lease       1615234.9\n   age_of_unit           1577116.4\n   dist_to_cbd            -28475.6\n   dist_to_eldercare        5598.4\n   dist_to_hawker         -17787.1\n   dist_to_park           -26016.4\n   dist_to_gpsch            8696.9\n   dist_to_mall            14133.8\n   dist_to_supermarket     29020.3\n   ************************Diagnostic information*************************\n   Number of data points: 3797 \n   Effective number of parameters (2trace(S) - trace(S'S)): 15.17437 \n   Effective degrees of freedom (n-2trace(S) + trace(S'S)): 3781.826 \n   AICc (GWR book, Fotheringham, et al. 2002, p. 61, eq 2.33): 110821.4 \n   AIC (GWR book, Fotheringham, et al. 2002,GWR p. 96, eq. 4.22): 110805.6 \n   BIC (GWR book, Fotheringham, et al. 2002,GWR p. 61, eq. 2.34): 107107.3 \n   Residual sum of squares: 1.045127e+15 \n   R-square value:  -13.20393 \n   Adjusted R-square value:  -13.26094 \n\n   ***********************************************************************\n   Program stops at: 2024-11-10 16:13:14.854665 \n```\n\n\n:::\n:::\n\n\n\n::: {.callout-tip title=\"gwr_adaptive summary\"}\n**Global Linear Regression**\n\nAdjusted R Square of 0.6902 indicates that the model is a good fit overall.\n\np-value of \\<2.2e-16 indicates that the model is statistically significant.\n\n**Geographically Weighted Regression**\n\nR-square value of -13.20393 may indicate over/under fitting leading to poor predictive performance in a localised analysis.\n:::\n\n### 2.4.4 Converting test sf data frame to SpatialPointDataFrame\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_data_sp <- as_Spatial(test_data) \ntrain_data_sp\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatialPointsDataFrame \nfeatures    : 3797 \nextent      : 11755.72, 46810.43, 28211.46, 48741.06  (xmin, xmax, ymin, ymax)\ncrs         : +proj=tmerc +lat_0=1.36666666666667 +lon_0=103.833333333333 +k=1 +x_0=28001.642 +y_0=38744.572 +ellps=WGS84 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs \nvariables   : 27\nnames       : month,       town, flat_type, block,  street_name, storey_range, floor_area_sqm, flat_model, lease_commence_date, remaining_lease, resale_price, storey_mid, age_of_unit,                                address, postal, ... \nmin values  : 19358, ANG MO KIO,    5 ROOM,     1, ADMIRALTY DR,     01 TO 03,             99,       3Gen,                1970,              45,       418000,          2,           4,         1 CHAI CHEE RD BEDOK Singapore, 081003, ... \nmax values  : 19692,     YISHUN,    5 ROOM,    9B,      ZION RD,     43 TO 45,            153,    Type S2,                2020,              95,      1460000,         44,          54, 9B BOON TIONG RD BUKIT MERAH Singapore, 824677, ... \n```\n\n\n:::\n:::\n\n\n\n### 2.4.5 Computing adaptive bandwith for test data\n\nDetermine the optimal bandwith to be used via bw.gwr() of GWmodel package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbw_adaptive_test <- bw.gwr(resale_price ~\n                        floor_area_sqm + \n                        storey_mid + \n                        remaining_lease +\n                        age_of_unit +\n                        dist_to_cbd +\n                        dist_to_eldercare +\n                        dist_to_hawker +\n                        dist_to_park +\n                        dist_to_gpsch +\n                        dist_to_mall +\n                        dist_to_supermarket,\n                        data=test_data_sp,\n                        approach=\"CV\",\n                        kernel=\"gaussian\",\n                        adaptive=TRUE,\n                        longlat=FALSE)\n```\n:::\n\n\n\nThe result shows that 1227 neighbour points will be the optimal bandwidth to be used if adaptive bandwidth is used for the test data set.\n\nWe will write and read bw_adaptive to avoid the long calculation time for the adaptive bandwith.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(bw_adaptive_test, \"data/model/bw_adaptive_test.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbw_adaptive_test <- read_rds(\"data/model/bw_adaptive_test.rds\")\n```\n:::\n\n\n\n### 2.4.3 Constructing the adaptive bandwith gwr model for train data\n\nTo calibrate the gwr-based hedonic pricing model by using adaptive bandwith and the Gaussian kernel using the code chunk below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngwr_adaptive_test <- gwr.basic(formula = resale_price ~\n                            floor_area_sqm + \n                            storey_mid + \n                            remaining_lease +\n                            age_of_unit +\n                            dist_to_cbd +\n                            dist_to_eldercare +\n                            dist_to_hawker +\n                            dist_to_park +\n                            dist_to_gpsch +\n                            dist_to_mall +\n                            dist_to_supermarket,\n                          data=test_data_sp,\n                          bw=bw_adaptive, \n                          kernel = 'gaussian', \n                          adaptive=TRUE,\n                          longlat = FALSE)\n```\n:::\n\n\n\nWe will write and read gwr_adaptive to store and avoid loading time.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(gwr_adaptive_test, \"data/model/gwr_adaptive_test.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngwr_adaptive_test <- read_rds(\"data/model/gwr_adaptive.rds\") \ngwr_adaptive_test\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   ***********************************************************************\n   *                       Package   GWmodel                             *\n   ***********************************************************************\n   Program starts at: 2024-11-10 16:13:08.045996 \n   Call:\n   gwr.basic(formula = resale_price ~ floor_area_sqm + storey_mid + \n    remaining_lease + age_of_unit + dist_to_cbd + dist_to_eldercare + \n    dist_to_hawker + dist_to_park + dist_to_gpsch + dist_to_mall + \n    dist_to_supermarket, data = train_data_sp, bw = bw_adaptive, \n    kernel = \"gaussian\", adaptive = TRUE, longlat = FALSE)\n\n   Dependent (y) variable:  resale_price\n   Independent variables:  floor_area_sqm storey_mid remaining_lease age_of_unit dist_to_cbd dist_to_eldercare dist_to_hawker dist_to_park dist_to_gpsch dist_to_mall dist_to_supermarket\n   Number of data points: 3797\n   ***********************************************************************\n   *                    Results of Global Regression                     *\n   ***********************************************************************\n\n   Call:\n    lm(formula = formula, data = data)\n\n   Residuals:\n    Min      1Q  Median      3Q     Max \n-382782  -46594   -5013   38707  468405 \n\n   Coefficients: (1 not defined because of singularities)\n                        Estimate Std. Error t value Pr(>|t|)    \n   (Intercept)         -326092.6    34355.5  -9.492  < 2e-16 ***\n   floor_area_sqm         6840.8      226.5  30.203  < 2e-16 ***\n   storey_mid             6733.6      227.2  29.642  < 2e-16 ***\n   remaining_lease        6710.2      139.4  48.143  < 2e-16 ***\n   age_of_unit                NA         NA      NA       NA    \n   dist_to_cbd          -28795.6      606.9 -47.449  < 2e-16 ***\n   dist_to_eldercare      4934.1     2059.0   2.396  0.01661 *  \n   dist_to_hawker       -20052.2     2366.4  -8.474  < 2e-16 ***\n   dist_to_park         -26228.0     5153.6  -5.089 3.77e-07 ***\n   dist_to_gpsch          7451.5      623.0  11.960  < 2e-16 ***\n   dist_to_mall           8609.8     3297.9   2.611  0.00907 ** \n   dist_to_supermarket   24820.8     8472.5   2.930  0.00341 ** \n\n   ---Significance stars\n   Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 \n   Residual standard error: 77500 on 3786 degrees of freedom\n   Multiple R-squared: 0.691\n   Adjusted R-squared: 0.6902 \n   F-statistic: 846.5 on 10 and 3786 DF,  p-value: < 2.2e-16 \n   ***Extra Diagnostic information\n   Residual sum of squares: 2.273806e+13\n   Sigma(hat): 77405.32\n   AIC:  96283.64\n   AICc:  96283.74\n   BIC:  92674.93\n   ***********************************************************************\n   *          Results of Geographically Weighted Regression              *\n   ***********************************************************************\n\n   *********************Model calibration information*********************\n   Kernel function: gaussian \n   Adaptive bandwidth: 3065 (number of nearest neighbours)\n   Regression points: the same locations as observations are used.\n   Distance metric: Euclidean distance metric is used.\n\n   ****************Summary of GWR coefficient estimates:******************\n                              Min.     1st Qu.      Median     3rd Qu.\n   Intercept           -1.4359e+08 -4.6410e+05  1.2529e+05  6.8694e+05\n   floor_area_sqm       6.6513e+03  6.7646e+03  7.1131e+03  7.2357e+03\n   storey_mid           6.5239e+03  6.6875e+03  6.7525e+03  6.8149e+03\n   remaining_lease     -1.9063e+06 -3.8314e+03  2.1069e+03  7.9490e+03\n   age_of_unit         -1.8576e+06 -1.0630e+04 -4.5961e+03  1.7402e+03\n   dist_to_cbd         -2.9471e+04 -2.9127e+04 -2.9011e+04 -2.8828e+04\n   dist_to_eldercare   -4.7075e+02  1.1548e+03  3.2754e+03  4.3116e+03\n   dist_to_hawker      -2.4960e+04 -2.4066e+04 -2.1531e+04 -1.8975e+04\n   dist_to_park        -2.8047e+04 -2.7750e+04 -2.6978e+04 -2.6753e+04\n   dist_to_gpsch        6.9449e+03  7.6369e+03  8.0696e+03  8.3483e+03\n   dist_to_mall        -1.0322e+03  4.6156e+02  8.1778e+03  1.3234e+04\n   dist_to_supermarket  1.5986e+04  1.9394e+04  2.2390e+04  2.5543e+04\n                              Max.\n   Intercept           190590906.7\n   floor_area_sqm           7339.0\n   storey_mid               7123.5\n   remaining_lease       1615234.9\n   age_of_unit           1577116.4\n   dist_to_cbd            -28475.6\n   dist_to_eldercare        5598.4\n   dist_to_hawker         -17787.1\n   dist_to_park           -26016.4\n   dist_to_gpsch            8696.9\n   dist_to_mall            14133.8\n   dist_to_supermarket     29020.3\n   ************************Diagnostic information*************************\n   Number of data points: 3797 \n   Effective number of parameters (2trace(S) - trace(S'S)): 15.17437 \n   Effective degrees of freedom (n-2trace(S) + trace(S'S)): 3781.826 \n   AICc (GWR book, Fotheringham, et al. 2002, p. 61, eq 2.33): 110821.4 \n   AIC (GWR book, Fotheringham, et al. 2002,GWR p. 96, eq. 4.22): 110805.6 \n   BIC (GWR book, Fotheringham, et al. 2002,GWR p. 61, eq. 2.34): 107107.3 \n   Residual sum of squares: 1.045127e+15 \n   R-square value:  -13.20393 \n   Adjusted R-square value:  -13.26094 \n\n   ***********************************************************************\n   Program stops at: 2024-11-10 16:13:14.854665 \n```\n\n\n:::\n:::\n\n\n\n::: {.callout-tip title=\"gwr_adaptive summary\"}\n**Global Linear Regression**\n\nAdjusted R Square of 0.6902 indicates that the model is a good fit overall.\n\np-value of \\<2.2e-16 indicates that the model is statistically significant.\n\n**Geographically Weighted Regression**\n\nR-square value of -13.26094 may indicate over/under fitting leading to poor predictive performance in a localised analysis.\n:::\n\n## 2.5 Preparing coordinates data\n\n### 2.5.1 Extracting coordinates data\n\nThe code chunk below will extract the x,y coordinates of the full, training and test data sets.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoords <- st_coordinates(hdb5rm_r_2023_sf2)\ncoords_train <- st_coordinates(train_data)\ncoords_test <- st_coordinates(test_data)\n```\n:::\n\n\n\nWrite and read into rds for future use.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(coords, \"data/model/coords.rds\" )\nwrite_rds(coords_train, \"data/model/coords_train.rds\" )\nwrite_rds(coords_test, \"data/model/coords_test.rds\" )\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncoords <- read_rds(\"data/model/coords.rds\" )\ncoords_train <- read_rds(\"data/model/coords_train.rds\" )\ncoords_test <- read_rds(\"data/model/coords_test.rds\" )\n```\n:::\n\n\n\n### 2.5.1 Dropping geometry field\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrain_data_nogeo <- train_data %>%\n  st_drop_geometry()\n```\n:::\n\n\n\n## 2.6 Calibrating Random Forest Model\n\nCalibrate a model to predict HDB resale price by using random forest function of ranger package.,\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(8888)\nrf <- ranger(resale_price ~\n               floor_area_sqm + \n               storey_mid + \n               remaining_lease +\n               age_of_unit +\n               dist_to_cbd +\n               dist_to_eldercare +\n               dist_to_hawker +\n               dist_to_park +\n               dist_to_gpsch +\n               dist_to_mall +\n               dist_to_supermarket,\n             data=train_data_nogeo)\nrf\n```\n:::\n\n\n\n::: {.callout-tip title=\"Random Forest result summary\"}\n**R Square of 0.896** indicates that the model has a good predictive performance and explains a substantial proportion of variance in the resale price.\n:::\n\nSave the random forest output into rds for future use.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(rf, \"data/model/rf.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrf <- read_rds(\"data/model/rf.rds\")\n```\n:::\n\n\n\n## 2.7 Calibrating Geographical Random Forest\n\nWe will use grf() of the SpatialML package to calibrate a model to predict HDB resale price.\n\n### 2.7.1 Calibrating using training data\n\nCalibrate a geographic random forest model by using the below code chunk.\n\n::: callout-note\nWe will use a bandwith of 55(km) as that represents the height of Singapore, i.e. width is less than 55. Representing the maximum spatial information of nearby data points is within a distance of 55km.\n\nNumber of trees is set at 50, to reduce the overall model training time.\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(8888)\ngwRF_adaptive <- grf(formula = resale_price ~\n                       floor_area_sqm + \n                       storey_mid + \n                       remaining_lease +\n                       age_of_unit +\n                       dist_to_cbd +\n                       dist_to_eldercare +\n                       dist_to_hawker +\n                       dist_to_park +\n                       dist_to_gpsch +\n                       dist_to_mall +\n                       dist_to_supermarket,\n                     dframe=train_data_nogeo,\n                     bw=55,\n                     kernel=\"adaptive\",\n                     coords=coords_train,\n                     ntree = 50)\n```\n:::\n\n\n\nWrite and read RDS for future use.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(gwRF_adaptive, \"data/model/gwRF_adaptive.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngwRF_adaptive <- read_rds(\"data/model/gwRF_adaptive.rds\")\n```\n:::\n\n\n\n### 2.7.2 Predicting by using test data\n\nWe will then use predict.grf() of SpatialML package to predict the resale value by using the test data and gwRF_adaptive model calibrated earlier.\n\n::: callout-warning\nTo Prof. Kam:\n\nAs the assignment specifies to predict the prices from July 2024 to September 2024, the testing data used here should be the HDB resale data for this period while the training data would consist of all the transactions from January 2023 to December 2023. An error has been made earlier from the data preparation to the data split. Due to time constraint I am not able to correct the training / test dataset used. I will correct this in an uncoming revision to this page.\n\nI will continue on the same dataset for this exercise but it would be using the data sampling method performed in section 2.1.\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_data_nogeo <- cbind(test_data, coords_test) %>%\n  st_drop_geometry()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngwRF_pred <- predict.grf(gwRF_adaptive,\n                         test_data_nogeo,\n                         x.var.name=\"X\",\n                         y.var.name=\"Y\",\n                         local.w=1,\n                         global.w=0)\n```\n:::\n\n\n\nBefore moving on, we will save the output of the prediction model into rds for future use.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(gwRF_pred, \"data/model/gwRF_pred.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngwRF_pred <- read_rds(\"data/model/gwRF_pred.rds\")\ngwRF_pred_df <- as.data.frame(gwRF_pred)\n```\n:::\n\n\n\nIn the code chunk below, cbind() is used to append the predicted values onto test_data_nogeo.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_data_p <- cbind(test_data_nogeo, gwRF_pred_df)\n```\n:::\n\n\n\nWrite and read test_data_p for future use.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(test_data_p, \"data/model/test_data_p.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_data_p <- read_rds(\"data/model/test_data_p.rds\")\n```\n:::\n\n\n\n### 2.7.3 Calculating the Root Mean Square Error (RMSE)\n\nRMSE measures how far predicted values are from observed values in a regression analysis. In the code chunk below, rmse() of Metrics package is used to compute the RMSE.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrmse(test_data_p$resale_price,\n     test_data_p$gwRF_pred)\n```\n:::\n\n\n\n### 2.7.4 Visualising the predicted values\n\nA scatterplot can be used to visualise the actual resale price and the predicted resale price by using the code chunk below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data=test_data_p,\n       aes(x = GRF_pred,\n           y = resale_price)) +\n  geom_point()\n```\n:::\n",
    "supporting": [
      "Take-home_Ex03b_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}